Домашнее задание к занятию 6. «Troubleshooting»
## Задача 1
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести эту операцию:

напишите список операций, которые вы будете производить для остановки запроса пользователя;

Через MongoDB Shell (mongosh) вывести информацию о текущих запущенных операциях через db.currentOp(<operations>), которые выполняются дольше 3 минут и получить ID запроса

```json
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
)
```
Убить запрос через db.killOp(opid)

```json
db.killOp(<opid of the query to kill>)
```

Предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

При создании запроса можно указать время его завершения в мс. через параметр maxTimeMS():

```json
db.location.find( { "town": { "$regex": "(Pine Lumber)",
                              "$options": 'i' } } ).maxTimeMS(30)
```
Вы можете добавить maxTimeMS поле в командный документ, чтобы установить ограничение времени в 45 миллисекунд для операции:
```json
db.runCommand( { distinct: "collection",
                 key: "city",
                 maxTimeMS: 45 } )
```

Проверить нагрузку производительности диска, памяти и ЦПУ которую потребляет MongoDB. Проблемы с производительностью могут указывать на то, что база данных работает с полной нагрузкой и что пришло время добавить к базе данных дополнительную емкость. В частности, рабочий набор приложения должен умещаться в доступной физической памяти.

## Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

- сначала происходит рост отношения записанных значений к истекшим,
- Redis блокирует операции записи.

Как вы думаете, в чём может быть проблема?

Если в базе данных есть много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек. ниже 25%. Многие ключи, срок действия которых истекает в один и тот же момент, могут быть источником задержки.


**NOTE**

Задержка, вызванная истечением срока действия
Redis удаляет ключи с истекшим сроком действия двумя способами:

Один ленивый способ истекает сроком действия ключа, когда он запрашивается командой, но оказывается, что срок его действия уже истек.
Один активный путь истекает через несколько ключей каждые 100 миллисекунд.
Активное истечение разработано, чтобы быть адаптивным. Цикл истечения запускается каждые 100 миллисекунд (10 раз в секунду) и будет выполнять следующие действия:

Пробные ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP ключи, вытесняющие все ключи с истекшим сроком действия.
Если более 25% ключей оказались просроченными, повторите.
Учитывая, что ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP по умолчанию установлено значение 20, а процесс выполняется десять раз в секунду, обычно активно истекает только 200 ключей в секунду. Этого достаточно, чтобы очистить БД достаточно быстро даже тогда, когда уже просроченные ключи не используются в течение длительного времени, так что ленивый алгоритм не помогает. В то же время срок действия всего 200 ключей в секунду не влияет на задержку экземпляра Redis.

Однако алгоритм является адаптивным и зациклится, если обнаружит, что более 25% ключей уже просрочены в наборе выбранных ключей. Но, учитывая, что мы запускаем алгоритм десять раз в секунду, это означает, что срок действия более чем 25% ключей в нашей случайной выборке истекает как минимум в одну и ту же секунду .

В основном это означает, что если в базе данных есть много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек. ниже 25%.

Такой подход необходим, чтобы не использовать слишком много памяти для ключей, срок действия которых уже истек, и обычно абсолютно безвреден, так как странно, что срок действия большого количества ключей истекает в одну и ту же секунду, но не исключено, что пользователь EXPIREATшироко используется с тем же временем Unix.

Короче говоря: имейте в виду, что многие ключи, срок действия которых истекает в один и тот же момент, могут быть источником задержки.

## Задача 3
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:
```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
 
Как вы думаете, почему это начало происходить и как локализовать проблему?

- Иногда форма “during query,” возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. Если вы знаете, что это происходит, попробуйте увеличить значение net_read_timeout по умолчанию с 30 секунд до 60 секунд или дольше, что достаточно для завершения передачи данных.

- Реже это может произойти, когда клиент пытается установить первоначальное соединение с сервером. В этом случае, если ваше connect_timeout значение установлено всего на несколько секунд, вы можете решить проблему, увеличив его до десяти секунд, возможно, больше, если у вас очень большое расстояние или медленное соединение. Вы можете определить, испытываете ли вы эту более редкую причину, используя SHOW GLOBAL STATUS LIKE 'Aborted_connects'. Он увеличивается на единицу за каждую первоначальную попытку подключения, которую прерывает сервер. Вы можете увидеть “reading authorization packet” как часть сообщения об ошибке; если это так, это также говорит о том, что это решение, которое вам нужно.

- Если причина не является ни одной из только что описанных, у вас может возникнуть проблема со BLOB значениями, превышающими max_allowed_packet, что может вызвать эту ошибку на некоторых клиентах. Иногда вы можете увидеть ER_NET_PACKET_TOO_LARGE ошибку, и это подтверждает, что вам нужно увеличить max_allowed_packet, которая по умолчанию имеет значение 1 МБ. Вам также может потребоваться увеличить максимальный размер пакета на стороне клиента. 
Вы можете получить больше информации о потерянных соединениях, запустив mysqld с параметром --log-warnings=2. Это регистрирует некоторые ошибки отключения в файле hostname.err.


## Задача 4
Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

```
postmaster invoked oom-killer
```
Как вы думаете, что происходит?

Когда у сервера или процесса заканчивается память, Linux предлагает 2 пути решения: обрушить всю систему или завершить процесс (приложение), Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.

Как бы вы решили эту проблему?

- Необходимо настроить рамки предвыделения оперативной памяти настройках ОС:
```
echo 2 > /proc/sys/vm/overcommit_memory
```
- Так же стоит выделить больше памяти Postgres-серверу.

**NOTE**

Есть ядре два основных параметра, отвечающих за overcommit памяти:
vm.overcommit_memory — отвечает за стратегию overcommit.
vm.overcommit_ratio — отвечает за уровень (в процентах) overcommit-а
Стратегии есть такие (см. файл с исходниками ядра mm/mmap.c):

0 - OVERCOMMIT_GUESS — эвристический подход к распределению памяти. В нем выделяется столько памяти, сколько хочет процесс. Но в swap/res попадает только те страницы, которые используются этим процессом.

1 - OVERCOMMIT_ALWAYS — overcommit памяти есть всегда. Использовать лучше с совсем кривыми приложениями и быть готовым при этому ко всему.

2 - OVERCOMMIT_NEVER — без overcommit. В этом случае допустимый объем пространства памяти будет swap+ram*overcommit_ratio/100 .

По умолчанию используется стратегия OVERCOMMIT_GUESS, а vm.overcommit_ratio находится в значение 50% и используется только в случае OVERCOMMIT_NEVER. Система резервирует около 3% памяти для процессов пользователя root.



---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
